# Gemini FullStack - ADK Frontend Application

## Overview

This document explains the frontend application (`App.tsx`) for the Gemini FullStack ADK (Agent Development Kit) sample. The application provides a chat-like interface where users can submit research queries and receive comprehensive reports generated by a multi-agent AI system.

## Core Functionality

The App component manages:

1. **User Sessions**: Creates and maintains user sessions for interacting with the backend
2. **Chat Interface**: Displays a chat-like interface for user-AI interaction
3. **Server-Sent Events (SSE)**: Processes streaming responses from the backend
4. **Agent Coordination**: Tracks and displays the activities of multiple specialized AI agents
5. **Research Timeline**: Shows the progress of research through various stages

## Key Components and State Management

### State Variables

```typescript
const [userId, setUserId] = useState<string | null>(null);
const [sessionId, setSessionId] = useState<string | null>(null);
const [appName, setAppName] = useState<string | null>(null);
const [messages, setMessages] = useState<MessageWithAgent[]>([]);
const [displayData, setDisplayData] = useState<DisplayData | null>(null);
const [isLoading, setIsLoading] = useState(false);
const [messageEvents, setMessageEvents] = useState<Map<string, ProcessedEvent[]>>(new Map());
const [websiteCount, setWebsiteCount] = useState<number>(0);
const [isBackendReady, setIsBackendReady] = useState(false);
const [isCheckingBackend, setIsCheckingBackend] = useState(true);
```

These state variables track:
- User and session information
- Chat messages
- Display data for the current response
- Loading states
- Events from different agents
- Count of websites referenced in research
- Backend availability status

### Backend Communication

The application communicates with a Python backend that uses Google's ADK to orchestrate multiple specialized AI agents. Key functions include:

1. **`createSession`**: Creates a new session with the backend
2. **`checkBackendHealth`**: Verifies if the backend is available
3. **`handleSubmit`**: Sends user queries to the backend and processes responses
4. **`retryWithBackoff`**: Implements exponential backoff for API calls

### Server-Sent Events (SSE) Processing

The app uses SSE to receive streaming updates from the backend's multi-agent system:

1. **`extractDataFromSSE`**: Parses SSE data to extract text, agent information, and metadata
2. **`processSseEventData`**: Processes the extracted data to update the UI
3. **`getEventTitle`**: Maps agent names to user-friendly event titles

## Agent System

The application interfaces with a sophisticated multi-agent system defined in the backend:

1. **`plan_generator`**: Creates a research plan
2. **`section_planner`**: Structures the report outline
3. **`section_researcher`**: Performs initial web research
4. **`research_evaluator`**: Evaluates research quality
5. **`enhanced_search_executor`**: Performs additional research if needed
6. **`report_composer_with_citations`**: Creates the final report with citations

Each agent's activities are tracked and displayed in the UI timeline.

## Key Workflows

### 1. Backend Connection

On initial load, the app checks if the backend is available:

```typescript
useEffect(() => {
  const checkBackend = async () => {
    setIsCheckingBackend(true);
    // Check if backend is ready with retry logic
    const maxAttempts = 60; // 2 minutes with 2-second intervals
    let attempts = 0;
    
    while (attempts < maxAttempts) {
      const isReady = await checkBackendHealth();
      if (isReady) {
        setIsBackendReady(true);
        setIsCheckingBackend(false);
        return;
      }
      
      attempts++;
      await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds between checks
    }
    
    // If we get here, backend didn't come up in time
    setIsCheckingBackend(false);
    console.error("Backend failed to start within 2 minutes");
  };
  
  checkBackend();
}, []);
```

### 2. Session Management

The app creates a session when a user submits their first query:

```typescript
const createSession = async (): Promise<{userId: string, sessionId: string, appName: string}> => {
  const generatedSessionId = uuidv4();
  const response = await fetch(`/api/apps/app/users/u_999/sessions/${generatedSessionId}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    }
  });
  
  if (!response.ok) {
    throw new Error(`Failed to create session: ${response.status} ${response.statusText}`);
  }
  
  const data = await response.json();
  return {
    userId: data.userId,
    sessionId: data.id,
    appName: data.appName
  };
};
```

### 3. Query Submission

When a user submits a query:

```typescript
const handleSubmit = useCallback(async (query: string, model: string, effort: string) => {
  // Create session if needed
  // Add user message to chat
  // Send message to backend
  // Process SSE response
  // ...
}, [processSseEventData]);
```

### 4. SSE Processing

The app processes streaming events from the backend:

```typescript
// Process all complete lines in the buffer
while ((eolIndex = lineBuffer.indexOf('\n')) >= 0 || (done && lineBuffer.length > 0)) {
  // Extract line
  // Process event data
  // Update UI
  // ...
}
```

### 5. Agent Activity Display

The app tracks and displays activities from different agents:

```typescript
if (agent && agent !== currentAgentRef.current) {
  currentAgentRef.current = agent;
}

// Add timeline events for different agent activities
setMessageEvents(prev => new Map(prev).set(aiMessageId, [...(prev.get(aiMessageId) || []), {
  title: eventTitle,
  data: { type: 'text', content: textParts.join(" ") }
}]));
```

## UI Components

The app renders different views based on the current state:

1. **`BackendLoadingScreen`**: Shown while checking if the backend is ready
2. **`WelcomeScreen`**: Initial screen with a form to submit queries
3. **`ChatMessagesView`**: Main interface showing the conversation and research progress

### Main Render Function

```typescript
return (
  <div className="flex h-screen bg-neutral-800 text-neutral-100 font-sans antialiased">
    <main className="flex-1 flex flex-col overflow-hidden w-full">
      <div className={`flex-1 overflow-y-auto ${(messages.length === 0 || isCheckingBackend) ? "flex" : ""}`}>
        {isCheckingBackend ? (
          <BackendLoadingScreen />
        ) : !isBackendReady ? (
          // Backend unavailable message
        ) : messages.length === 0 ? (
          <WelcomeScreen
            handleSubmit={handleSubmit}
            isLoading={isLoading}
            onCancel={handleCancel}
          />
        ) : (
          <ChatMessagesView
            messages={messages}
            isLoading={isLoading}
            scrollAreaRef={scrollAreaRef}
            onSubmit={handleSubmit}
            onCancel={handleCancel}
            displayData={displayData}
            messageEvents={messageEvents}
            websiteCount={websiteCount}
          />
        )}
      </div>
    </main>
  </div>
);
```

## Error Handling and Resilience

The application implements several resilience patterns:

1. **Exponential Backoff**: The `retryWithBackoff` function implements exponential backoff for API calls
2. **Backend Health Checks**: The app continuously checks if the backend is available
3. **Error State Display**: Shows appropriate error messages when the backend is unavailable
4. **Graceful Degradation**: Handles various error conditions in SSE processing

## Summary

The App.tsx file implements a sophisticated React frontend for a research assistant powered by Google's ADK. It manages user sessions, processes streaming responses from a multi-agent system, and presents research progress and results in a user-friendly chat interface. The application handles complex state management, backend communication, and UI rendering to provide a seamless experience for users seeking comprehensive research reports on various topics.
